# C语言指针与内存

## 初始指针

```
*a	指针		去a的内存地址中的值
&a	取地址
void change(int a, int b){}		只将变量的值传递进函数

void change(int *a, int *b){}		传递变量的地址
```

## GDB

```
gcc -g main.c -o main.out 	这样生成的main.out可以调试
```

gdb 指令

```
list/l 显示代码
start 开始执行
print/p a 打印变量a
next/n	执行下一行
s	进入当前函数
bt 查看函数堆栈
f 1	切换函数堆栈到1
x/3d 0x7fffffffd604   从这个地址开始连续显示3个地址中包含的值，以数值方式显示
x/6cb 0x7fffffffd604 字符数组以\0结尾，那么这个指令打印的是五个字符+/0，以byte方式显示
```

## 内存与指针

### 数据中的内存表示方法

1. 一个字节有8个二进制位

2. 计算机把内存看作一个整体进行处理

3. 32位操作系统最大只能使用4G

   1. 地址总线是32位，也就是寻址空间是32位，给内存编号只能到32 位，只有2的32次方个状态=1024×1024×1024×4=4G

4. 64位操作系统最大可以有？……反正足够大

5. 操作系统对内存地址编号，每个编号对应唯一的内存字节的地址，一个字节存储8个二进制数组

6. 内存交给操作系统管理

7. 操作系统除了编号之外，还可以给内存做一定的规划，在64为中使用的内存只占前48位就足够了，剩余的部分给操作系统内存

8. 系统内核-栈-自由可分配内存-堆-数据段-代码段

   1. 代码段：代码编译后的二进制数据在程序运行过程中被加载到内存中
   2. 数据段：声明的一些全局变量或者一些常量
   3. 堆
   4. 自由可分配内存
   5. 栈

   

### 变量和指针的本质

	1. C语言不允许对代码段进行操作
 	2. 函数执行管理顺序在栈里
 	3. 变量的本质是什么
      	1. 变量名只是一个代号
      	2. 变量的本质就是内存
 	4. 指针本质就是地址

### 操作系统对内存的管理

1. 编译器会对代码的执行进行一定程度的优化,比如在初始化过程中会把所有同一类型的变量放在内存中相近的位置
2. 指针在32位中占4个字节，在64位中占8个字节
3. 代码段以及数据段中，内存地址从低到高转移，栈中从高到底

### 函数栈及数据段内存

### 函数指针与指针指向的数据访问

1. 函数指针经常用于回调函数、

   

## 字符串与数组

1. C语言不做指针的安全性检查，对任何地址都可以操作
2.  如果p是指针，p++对先判断数据类型，再根据数据类型移动到下一个地址--指针偏移：性能高，效率好
3. 指针变量本质上是地址，数组本质上也是地址，所有数组操作都可以用指针代替（但反过来不行啊，因为数组是指针常量，他这个地址不能改。指针变量的话指向的地址可以改）。
4. char *str2="world", 这种声明的话“world”将会被保存到代码段，在编译的过程中就储存过去，在执行过程中不能对这个地址进行操作。
5. ""与''是不同的。。。
6. 字符数组以\0结尾
7. 字符数组非常容易占用没分给他的内存，要避免这种情况。

```
char str[]="hello";
char *str2="world";
char str3[10];
```

